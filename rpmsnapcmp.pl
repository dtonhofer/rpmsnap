#!/usr/bin/perl -w

# ================================================================================
# "rpmsnapcmp.pl": Compare two files generated by "rpmsnap.pl" at different points
# in time or on different machines.
#
# Arguments passed: two rpmsnap files, the "reference" and the "variant" (in 
# that order). The variant is compared against the reference and the list of
# differences is output. In case you are looking for a list of missing packages
# to pass to "yum", use the "-p" one-liner.
#
# You can also use the ouput to look for and install missing packages.
# For example, if the run of rpmsnapcmp.pl has yielded output "OUT", you
# could consider installing missing "perl" packages using:
#
# grep "perl" OUT | grep "Missing" | cut --field=1 --delimiter=":" | xargs yum -y install
#
# Maintainer: David Tonhofer <ronerycoder@gluino.name>
# ================================================================================
# Distributed under the MIT License,
# See http://www.opensource.org/licenses/mit-license.php
# 
# Copyright (c) 2011 by M-PLIFY S.A. 
#                       21, rue Glesener
#                       L-1631 Luxembourg
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ================================================================================

use strict;
use Getopt::Std;
use File::Basename;
use File::Spec::Functions;
use Sys::Hostname;

# ----
# How do we call the files passed to the program?
# The first one given is the "reference".
# The second one given is the "variant" which is compared against the "reference".
# One could also name them "left-hand" and "right-hand", which is clearer for the user.
# ----

my $refName = "reference";
my $varName = "variant";

# ----
# Argument checking and processing. 
# ----

sub numerize {
   my ($x) = @_;
   $x =~ /\.(\d{4})-(\d{2})-(\d{2})_(\d{2}):(\d{2}):(\d{2})\.txt$/;
   return ((((($1 * 100 + $2)*100 + $3)*100 + $4)*100 + $5)*100 + $6)
}
 
sub resolveFile {
   my($files, $file, $reldir, $reldirset) = @_; 
   my $errmsg;
   my $thefile;
   if ($reldirset && $file =~ /^latest(-*)$/) {
      my $delta = length($1);
      if ($delta > @$files) {
         # There is not enough files in the array...
         $errmsg = "A file $delta steps ago in directory '$reldirset' was requested but there are only " . scalar(@$files) . " files in there!"
      }
      else {
         $thefile = catfile($reldir, $$files[$delta])
      }
   }
   elsif ($reldirset) {     
      $thefile = catfile($reldir, $file)
   }
   else {
      $thefile = $file
   }   
   if (!(-e $thefile && -f $thefile)) {
      $errmsg = "File '$thefile' does not exist!"
   }
   return ($thefile, $errmsg)
}
 
sub argsAction {
   my $basename = basename($0);
   my $lkey = 'local';
   my $usage =<<"USAGE_HEREDOC";
Usage: $basename [-x] [-p] [-a] [-r DIR] reference_file variant_file

The variant file is compared against the reference file and any
differences are printed out.

-x       : Exchange reference_file and variant_file positions on command line;
           just to avoid editing the command line.
-p       : List packages missing in variant_file in a one-liner; for further
           processing via 'dnf' or 'yum'.
-a       : Disregard 'architecture' when comparing; may give better matches.
-r DIR   : The reference_file and variant_file, if relative, are relative to 
           directory 'DIR'.
           If 'DIR' is the string "$lkey", a directory based on the hostname is 
           used instead, according to a hardcoded algorithm.
           Additionally, in this case:
           If the string "latest" is given as a file, it refers to that file
           in 'DIR' that has been created most recently according to its 
           timestamp-bearing filename.
           Adding one or several "-" to "latest" (e.g. "latest---") selects
           successively older files.
           So to compare latest and latest-but-one for example:
           $basename -r$lkey latest- latest
USAGE_HEREDOC

   # case of no arguments at all

   if (@ARGV == 0) {
      print STDERR $usage;
      exit 1
   }

   # Get arguments using getopts(), not getopt()
   # http://perldoc.perl.org/Getopt/Std.html
   # http://www.perlmonks.org/?node_id=88222
   # (See also: http://search.cpan.org/~ether/MooseX-Getopt-0.71/lib/MooseX/Getopt.pm)
   # The getopts() function returns true unless an invalid option was found.
   # Switchful arguments are expected first, and processed. Anything left over
   # is left in @ARGV

   my %args;
   getopts('hxpar:', \%args);

   my $help = $args{h} ? 1 : 0;
   if ($help) { 
      print STDERR $usage;
      exit 1 
   }
 
   my $exchange   = $args{x} ? 1 : 0;
   my $print      = $args{p} ? 1 : 0;
   my $drgarch    = $args{a} ? 1 : 0;
   my $reldir     = $args{r};
   my $reldirset  = $reldir ? 1 : 0;

   # There must be exactly two arguments left, the "left-hand" and "right-hand"
   # (we don't check where they are in the command line, we don't really care)

   if (@ARGV != 2) { 
      print STDERR "** Expecting the reference file and the variant file. Instead: @ARGV\n\n";
      print STDERR $usage;
      exit 1
   }
 
   # The remaining arguments are the files (we hope). We may need to exchange them.

   my $referenceFile = $ARGV[0];
   my $variantFile   = $ARGV[1];

   if ($exchange) {
      ($variantFile,$referenceFile) = ($referenceFile,$variantFile)
   }

   # Determine relative-directory and check that it exists if needed

   if ($reldirset) {
      my $construct = (lc($reldir) eq lc($lkey));
      if ($construct) {
         $reldir = catdir(rootdir(),'usr','local','toolbox','rpmsnap','data',hostname());
      }
      if (!(-e $reldir && -d $reldir)) {
         if ($construct) {
            print STDERR "** The '$lkey' relative-directory is: '$reldir'\n"
         } 
         else { 
            print STDERR "** The relative-directory given is: '$reldir'\n"
         }
         print STDERR "** However, that directory does not exist.\n\n";
         print STDERR $usage;
         exit 1
      }
   }

   # If any of the requested files looks like 'latest' (if "reldirset") then we need to get the
   # contents of relative-directory and sort it according to timestamp-in-the-filename.
   # Otherwise, just grab the file normally.

   my($theReferenceFile, $errmsgRf);
   my($theVariantFile,   $errmsgVf);
 
   if ($reldirset && ($referenceFile =~ /^latest-*$/ || $variantFile =~ /^latest-*$/)) {
      opendir(my $dh, $reldir) || die "Cannot open the relative-directory '$reldir': $!";
      my @files = grep { !/^\./ && /\.\d{4}-\d{2}-\d{2}_\d{2}:\d{2}:\d{2}\.txt$/ && -f catfile($reldir,$_) } readdir($dh);
      closedir($dh);
      @files = sort { 
         my $aval = numerize($a);
         my $bval = numerize($b);
         # print "$a $b $aval $bval " . ($aval <=> $bval) . "\n";
         ($aval <=> $bval) * -1
      } @files;
      ($theReferenceFile, $errmsgRf) = resolveFile(\@files, $referenceFile, $reldir, $reldirset);
      ($theVariantFile,   $errmsgVf) = resolveFile(\@files, $variantFile,   $reldir, $reldirset); 
   } else {
      ($theReferenceFile, $errmsgRf) = resolveFile(\[], $referenceFile, $reldir, $reldirset);
      ($theVariantFile,   $errmsgVf) = resolveFile(\[], $variantFile,   $reldir, $reldirset); 
   }

   if ($errmsgRf || $errmsgVf) {
      if ($errmsgRf) {
         print STDERR "** Reference file ($referenceFile) problem: $errmsgRf\n"
      }
      if ($errmsgVf) {
         print STDERR "** Variant file ($variantFile) problem: $errmsgVf\n"
      }
      print STDERR "\n";
      print STDERR $usage;
      exit 1
   }

   # Debugging

   my $debug = 0;
   if ($debug) {
      print "referenceFile: '$theReferenceFile'\n";
      print "               from '$referenceFile'\n";
      print "variantFile  : '$theVariantFile'\n";
      print "               from '$variantFile'\n";
      print "print        : $print\n";
      print "drgarch      : $drgarch\n";
      print "reldirset    : $reldirset\n";
      print "reldir       : $reldir\n" if $reldirset;
   }

   return ($print,$drgarch,$theReferenceFile,$theVariantFile)
}

my ($print,$drgarch,$referenceFile,$variantFile) = argsAction();

# ----
# Read files into (references to) array of lines
# ----

my $variantLines   = slurpFile($variantFile,$varName);
my $referenceLines = slurpFile($referenceFile,$refName);

# ----
# Interpret the lines just read, filling hashes mapping "package names" to "package descriptors"
# ----

my $varPackages = {};
my $refPackages = {};

registerPackages($varPackages,$variantLines,$variantFile,$drgarch);
registerPackages($refPackages,$referenceLines,$referenceFile,$drgarch);

# ----
# Compare contents of $varPackages and $refPackages
# ----

my $disPackageNames    = {} ; # packages that *disappeared* when going from "ref" to "var"; map package name to "1"
my $appPackageNames    = {} ; # packages that *appeared* when going from "ref" to "var"; map package name to "1"
my $changedPackageList = [] ; # accumulate detail hashes of changed packages
my $disPackageList     = [] ; # accumulate detail hashes of reference packages not matching
my $appPackageList     = [] ; # accumulate detail hashes of variant packages not matching

for my $packName (sort keys %$refPackages) {
   #
   # If there is no corresponding package (with the same name) in the variant, register a missing package
   # 
   if (!exists $$varPackages{$packName}) {
      $$disPackageNames{$packName} = 1;
      next
   }
   #
   # Otherwise if there is at least one corresponding package, check details
   #
   my $refPacksWithSameName = $$refPackages{$packName};
   my $varPacksWithSameName = $$varPackages{$packName};
   #
   # Match reference packages against variant packages (matched variant packages are marked MATCHED)
   #
   for my $refCompoKey (keys %$refPacksWithSameName) {
      if (exists $$varPacksWithSameName{$refCompoKey}) {
         # perfect match
         my $varPackDetails = $$varPacksWithSameName{$refCompoKey};
         $$varPackDetails{MATCHED} = 1
      }
      else {
         # imperfect match; register difference
         my $refPackDetails = $$refPacksWithSameName{$refCompoKey};
         findVariantCorrespondingToReference($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disPackageList);
      }
   }
   #
   # Collect still unmatched variant packages
   #
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      my $matched        = $$varPackDetails{MATCHED};
      if (!defined($matched) || !$matched) {
         my $details = { NAME        => $packName,
                         VAR_VENDOR  => $$varPackDetails{VENDOR} ,
                         VAR_VERSION => $$varPackDetails{VERSION},
                         VAR_RELEASE => $$varPackDetails{RELEASE}, };
         if (!$drgarch) {
            $$details{VAR_ARCH} = $$varPackDetails{ARCH}
         }
         push(@$appPackageList,$details)
      }
   }
}

for my $packName (sort keys %$varPackages) {
   #
   # If there is no corresponding package (with the same name) in the reference, register an appearing package
   # 
   if (!exists $$refPackages{$packName}) {
      $$appPackageNames{$packName} = 1
   }
}

# ----
# Prettyprint out
# ----

# determine max length of the package name first

my $maxPackName = 0;

{ 
   for my $str (keys %$disPackageNames , keys %$appPackageNames) { 
      my $len = length($str); 
      if ($len > $maxPackName) { $maxPackName = $len }
   }
   for my $packDetails (@$changedPackageList, @$disPackageList, @$appPackageList) {
      my $len = length("$$packDetails{NAME}");
      if ($len > $maxPackName) { $maxPackName = $len }
   }
}

# printout appeared/disappeared packages (names only; one could consider also adding package information)
   
{
   my $format = "%-${maxPackName}s : %s\n";
   for my $str (sort keys %$disPackageNames) { 
      print sprintf($format,$str,"Missing in the $varName, but found in the $refName");
   }
   for my $str (sort keys %$appPackageNames) { 
      print sprintf($format,$str,"Found in the $varName, but missing in the $refName");
   }
}

# printout packages that changed

{
   my $maxLenHash = buildMaxLengthHash($changedPackageList);

   my $maxRefVerRel  = $$maxLenHash{REF_VERSION} + 3 + $$maxLenHash{REF_RELEASE} + 2;
   my $maxVarVerRel  = $$maxLenHash{VAR_VERSION} + 3 + $$maxLenHash{VAR_RELEASE} + 2;
   my $maxRefVendor  = $$maxLenHash{REF_VENDOR}  + 2; # +2 to accomodate quotes
   my $maxRefArch    = $$maxLenHash{REF_ARCH}    + 2; # +2 to accomodate quotes

   my $format = "%-${maxPackName}s : Changed: %-${maxRefVerRel}s ---> %-${maxVarVerRel}s    (%-${maxRefVendor}s";
 
   if ($drgarch) { 
      $format .= ")\n";
   }
   else {
      $format .= ", %-${maxRefArch}s)\n";
   }

   for my $packDetails (sort detailHashSort @$changedPackageList) {
      my $packName   = $$packDetails{NAME};        # always exists
      my $refVersion = $$packDetails{REF_VERSION}; # always exists
      my $refRelease = $$packDetails{REF_RELEASE}; # always exists
      my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
      my $varVersion = $$packDetails{VAR_VERSION}; # always exists
      my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
      if ($drgarch) {
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'");
      }
      else {
         my $refArch = $$packDetails{REF_ARCH};
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'","'$refArch'");
      } 
   }
}

# printout packages that appeared/disappeared but for which a package with the same name (but another architecture etc) already existed

{

   my @ovrPackageList = ( @$appPackageList, @$disPackageList ); # merge lists
   
   my $maxLenHash = buildMaxLengthHash( \@ovrPackageList );

   my $maxVersion = max($$maxLenHash{REF_VERSION} , $$maxLenHash{VAR_VERSION});
   my $maxRelease = max($$maxLenHash{REF_RELEASE} , $$maxLenHash{VAR_RELEASE});

   my $maxVerRel  = $maxVersion + 3 + $maxRelease                                + 2; # +2 to accommodate quotes
   my $maxVendor  = max($$maxLenHash{REF_VENDOR}  , $$maxLenHash{VAR_VENDOR})    + 2; # +2 to accommodate quotes
   my $maxArch    = max($$maxLenHash{REF_ARCH}    , $$maxLenHash{VAR_ARCH})      + 2; # +2 to accommodate quotes

   my $disFormat = "%-${maxPackName}s : %-${maxVerRel}s in $refName has no counterpart in $varName (%-${maxVendor}s";
   my $appFormat = "%-${maxPackName}s : %-${maxVerRel}s in $varName has no counterpart in $refName (%-${maxVendor}s";
 
   if ($drgarch) { 
      $disFormat .= ")\n";
      $appFormat    .= ")\n";
   }
   else {
      $disFormat .= ", %-${maxArch}s)\n";
      $appFormat    .= ", %-${maxArch}s)\n";
   }

   # Sort the "appeared" and "disappered" list, then interleave the lines when printing.
   # This makes for a better-to-read printout than just printing all the "appeared" then
   # all the "disappeared" packages in separate loops.
   
   my @disSortedL = (sort detailHashSort @$disPackageList);
   my @appSortedL = (sort detailHashSort @$appPackageList);

   my $disSorted = \@disSortedL;
   my $appSorted = \@appSortedL;

   my $disIndex    = 0;
   my $disIndexMax = @$disSorted * 1;
   my $appIndex    = 0;
   my $appIndexMax = @$appSorted * 1;
   
   while ($disIndex < $disIndexMax || $appIndex < $appIndexMax) {
      my $disPackDetails; 
      my $appPackDetails;
      #
      # Obtain package details if there are any in the repective list
      #  
      if ($disIndex < $disIndexMax) { $disPackDetails = $$disSorted[$disIndex] }
      if ($appIndex < $appIndexMax) { $appPackDetails = $$appSorted[$appIndex] }
      #
      # Find out which one to write out depending on what exists
      #   
      if (!$disPackDetails) {
         printAppearedPackage($appPackDetails,$drgarch,$appFormat);
         $appIndex++
      }
      elsif (!$appPackDetails) {
         printDisappearedPackage($disPackDetails,$drgarch,$disFormat);
         $disIndex++
      }
      else {
         die unless $disPackDetails && $appPackDetails;
         my $cmp = ($$disPackDetails{NAME} cmp $$appPackDetails{NAME}); # corresponds to "detailHashSort" used above
         if ($cmp <= 0) {
            printDisappearedPackage($disPackDetails,$drgarch,$disFormat);
            $disIndex++         
         }
         else {
            printAppearedPackage($appPackDetails,$drgarch,$appFormat);
            $appIndex++
         }
      }
   }
}

# 
# Additionally print results for a copy-and-paste into the command line of "yum"
# if so asked via "print" flag: the packages that disappeared in the variant, and
# thus may have to be added.
#

if ($print && (keys %$disPackageNames)) {
   print "Packages to be added to $varName:\n";
   print join(" ",sort keys %$disPackageNames);
   print "\n"
}

# --------------------------------------------------------------------------------
# Print the "disappeared" package, i.e. the reference part of "packDetails"
# --------------------------------------------------------------------------------

sub printDisappearedPackage {
   my($packDetails,$drgarch,$disFormat) = @_;
   my $packName   = $$packDetails{NAME};        # always exists
   my $refVersion = $$packDetails{REF_VERSION}; # always exists
   my $refRelease = $$packDetails{REF_RELEASE}; # always exists
   my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
   if ($drgarch) {
      print sprintf($disFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'");
   }
   else {
      my $refArch = $$packDetails{REF_ARCH};
      print sprintf($disFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'","'$refArch'");
   }
}

# --------------------------------------------------------------------------------
# Print the "appeared" package, i.e. the variant part of "packDetails"
# --------------------------------------------------------------------------------

sub printAppearedPackage {
   my($packDetails,$drgarch,$appFormat) = @_;
   my $packName   = $$packDetails{NAME};        # always exists
   my $varVersion = $$packDetails{VAR_VERSION}; # always exists
   my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
   my $varVendor  = $$packDetails{VAR_VENDOR};  # always exists
   if ($drgarch) {
      print sprintf($appFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'");
   }
   else {
      my $varArch = $$packDetails{VAR_ARCH};
      print sprintf($appFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'","'$varArch'");
   }
}


# --------------------------------------------------------------------------------
# Build map of "max string length encountered" for a set of keys
# Each of the "keys" given below will have a value; if the key is not encountered
# in the passed hash, it will be 0.
# --------------------------------------------------------------------------------

sub buildMaxLengthHash {
   my($packDetailsList) = @_;
   my $maxLenHash = {};
   my $keys   = [ 'REF_VENDOR','REF_VERSION','REF_RELEASE','VAR_VERSION','VAR_RELEASE','REF_ARCH', 'VAR_VENDOR', 'VAR_ARCH' ];
   for my $key (@$keys) { 
      $$maxLenHash{$key} = 0 
   }
   for my $packDetails (@$packDetailsList) {
      for my $key (@$keys) { 
         if (exists $$packDetails{$key}) {            
            my $len = length("$$packDetails{$key}");
            if ($len > $$maxLenHash{$key}) { $$maxLenHash{$key} = $len }
         }
      }
   }
   return $maxLenHash
}

# --------------------------------------------------------------------------------
# Sort two package detail hashes by name
# --------------------------------------------------------------------------------

sub detailHashSort {
   my $name_a = $$a{NAME};
   my $name_b = $$b{NAME};
   return $name_a cmp $name_b
}

# --------------------------------------------------------------------------------
# Inner loop of comparison
# --------------------------------------------------------------------------------

sub findVariantCorrespondingToReference {
   my($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disappearedPackageList) = @_;
   my $found      = 0; 
   my $packName   = $$refPackDetails{NAME};
   my $refVersion = $$refPackDetails{VERSION};
   my $refRelease = $$refPackDetails{RELEASE};
   my $refVendor  = $$refPackDetails{VENDOR};
   my $changeDetails = { NAME        => $packName,
                         REF_VENDOR  => $refVendor,
                         REF_VERSION => $refVersion,
                         REF_RELEASE => $refRelease };
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      die unless ($$varPackDetails{NAME} eq $packName);
      my $varVersion  = $$varPackDetails{VERSION};
      my $varRelease  = $$varPackDetails{RELEASE};
      my $varVendor   = $$varPackDetails{VENDOR};
      # we know the package has the same name but that otherwise doesn't match fully
      # find out what actually matches; we demand that the vendor match
      if ($refVendor eq $varVendor) {
         if ($drgarch) {
            $$changeDetails{VAR_VERSION} = $varVersion;
            $$changeDetails{VAR_RELEASE} = $varRelease;
            push(@$changedPackageList,$changeDetails);
            # Mark that the variant package has been considered so that it can be skipped in the next loop
            $$varPackDetails{MATCHED} = 1;
            $found++
         }
         else {
            my $varArch = $$varPackDetails{ARCH};
            my $refArch = $$refPackDetails{ARCH};
            if ($refArch eq $varArch) {
               $$changeDetails{VAR_VERSION} = $varVersion;
               $$changeDetails{VAR_RELEASE} = $varRelease;
               $$changeDetails{REF_ARCH}    = $refArch;
               push(@$changedPackageList,$changeDetails);
               # Mark that the variant package has been considered so that it can be skipped in the next loop
               $$varPackDetails{MATCHED} = 1;
               $found++
            }
         }
      }
   }
   #
   # If nothing was found at loop's end, register that (happens there is a package with the same name but
   # differing vendors or differing architectures)
   #
   if (!$found) {
      if (!$drgarch) { 
         $$changeDetails{REF_ARCH} = $$refPackDetails{ARCH}
      } 
      push(@$disappearedPackageList,$changeDetails)
   }
}

# --------------------------------------------------------------------------------
# Just read a file
# --------------------------------------------------------------------------------

sub slurpFile {
   my($file,$type) = @_;
   my $res = open(my $rfh,"<",$file);
   if (!$res) {
      print STDERR "Could not open the $type file '$file' for reading: $! -- exiting\n";
      exit 1
   }
   my @lines = <$rfh>;
   close($rfh) or die "Could not close type file '$file': $!\n";
   return \@lines
}

# --------------------------------------------------------------------------------
# Parse bunch of "lines" read from "file" and register package entries in "hash".
#
# Hash key is the name of the package (i.e. the "software name" with no version
# or release string). Several entires with the same package name may exist. Thus:
#
# Hash value is itself a hash for which:
#
#    Hash key is a string composed of the strings for "version,release,vendor,architecture"
#       or "version,release,vendor" if architecture shall be diregarded.
#
#    Hash value is itself a hash which basically repeats the value stringified in the key
#       for easier retrieval:
#
#       Hash key is a composite of NAME, VERSION, RELEASE, VENDOR and possibly ARCH
#       (the "composite key")
#
#       Hash value is simply the value string corresponding to key
# --------------------------------------------------------------------------------

sub registerPackages {
   my($hash,$lines,$file,$drgarch) = @_;
   for my $line (@$lines) {
      chomp $line;
      $line =~ s/·/ /g; # spaces may have been replaced by dots for better legibility, re-replace
      if ($line =~ /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S.+?)\s*:\s+(\S{9})\s+/) {
         my $name    = $1;
         my $version = $2;
         my $release = $3;
         my $arch    = $4;
         my $vendor  = $5;
         if (! exists $$hash{$name}) {
            $$hash{$name} = {}
         }
         my $subHash  = $$hash{$name};
         my $compoKey = "$version,$release,$vendor";
         if ($drgarch) {
            # disregard architecture; this may overwrite existing hash entry for another architecture
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release ,
                                     VENDOR  => $vendor } 
         }
         else {
            $compoKey = "$compoKey,$arch";
            if (exists $$subHash{$compoKey}) {
               print STDERR "An entry for package '$name' with version '$version', release '$release', architecture '$arch', vendor '$vendor' already exists in file '$file' -- exiting\n";
               exit 2
            }
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release , 
                                     VENDOR  => $vendor ,
                                     ARCH    => $arch }
         }
      }
      else {
         print STDERR "Could not parse line '$line'\n"
      }
   }
}

# --------------------------------------------------------------------------------
# Numerical max
# --------------------------------------------------------------------------------

sub max {
   my($a,$b) = @_;
   if ($a > $b) {
      return $a
   }
   else {
      return $b
   }
}

