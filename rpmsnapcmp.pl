#!/usr/bin/perl -w

# ================================================================================
# "rpmsnapcmp.pl": Compare two files generated by "rpmsnap.pl" at different points
# in time or on different machines.
#
# Arguments passed: two rpmsnap files, the "reference" and the "variant" (in 
# that order). The variant is compared against the reference and the list of
# differences is output. In case you are looking for a list of missing packages
# to pass to "yum", use the "-p" one-liner.
#
# Maintainer: d.tonhofer@m-plify.com
# ================================================================================
# Distributed under the MIT License,
# See http://www.opensource.org/licenses/mit-license.php
# 
# Copyright (c) 2011 by M-PLIFY S.A. 
#                       21, rue Glesener
#                       L-1631 Luxembourg
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ================================================================================

use strict;

# ----
# Simple argument checking and processing, use package Getopt::Long for anything
# more complex
# ----

if (@ARGV < 2) {
   print STDERR "You have to give two files: 1) The reference file 2) The variant file.\n";
   print STDERR "The variant is then compared against the reference.\n";
   print STDERR "Additional operations:\n";
   print STDERR "-r : reverse reference and variant\n";
   print STDERR "-p : list packages missing in variant in one-liner\n";
   print STDERR "-a : disregard architecture\n";
   exit 1
}

my $ix      = 0;
my $reverse = 0;
my $print   = 0;
my $drgarch = 0;
my $referenceFile;
my $variantFile;

while (defined $ARGV[$ix]) {
   if ($ARGV[$ix] eq '-r') { 
      $reverse = 1
   }
   elsif ($ARGV[$ix] eq '-p') { 
      $print = 1
   }
   elsif ($ARGV[$ix] eq '-a') { 
      $drgarch = 1
   }
   elsif (!($ARGV[$ix] =~ /^-/)) {
      if (!$referenceFile) {
         $referenceFile = $ARGV[$ix]
      }
      elsif (!$variantFile) {
         $variantFile = $ARGV[$ix]
      }
      else {
         die "Unexpected filename $ARGV[$ix]\n";
      }
   }
   else {
      die "Unusable argument $ARGV[$ix]\n"
   }
   $ix++
}

if (!$variantFile) {
   print STDERR "The variant file was not given -- exiting\n";
   exit 1
}

if (!$referenceFile) {
   print STDERR "The reference file was not given -- exiting\n";
   exit 1
}

if ($reverse) {
   ($variantFile,$referenceFile) = ($referenceFile,$variantFile)
}

# ----
# Check that files exist, then read them into (references to) array of lines
# ----

if (! -f $variantFile) {
   print STDERR "The variant file '$variantFile' does not exist -- exiting\n";
   exit 1
}

if (! -f $referenceFile) {
   print STDERR "The reference file '$referenceFile' does not exist -- exiting\n";
   exit 1
}

my $variantLines   = slurpFile($variantFile,'variant');
my $referenceLines = slurpFile($referenceFile,'reference');

# ----
# Interpret the lines just read, filling hashes mapping "package names" to "package descriptors"
# ----

my $varPackages = {};
my $refPackages = {};

registerPackages($varPackages,$variantLines,$variantFile,$drgarch);
registerPackages($refPackages,$referenceLines,$referenceFile,$drgarch);

# ----
# Compare contents of $varPackages and $refPackages
# ----

my $disappearedPackageNames    = {} ; # packages that disappeared going from "ref" to "var"; map package name to "1"
my $appearedPackageNames       = {} ; # packages that appeared going from "ref" to "var"; map package name to "1"
my $changedPackageList         = [] ; # accumulate detail hashes of changed packages
my $disappearedPackageList     = [] ; # accumulate detail hashes of reference packages not matching
my $appearedPackageList        = [] ; # accumulate detail hashes of variant packages not matching

for my $packName (sort keys %$refPackages) {
   #
   # If there is no corresponding package (with the same name) in the variant, register a missing package
   # 
   if (!exists $$varPackages{$packName}) {
      $$disappearedPackageNames{$packName} = 1;
      next
   }
   #
   # Otherwise if there is at least one corresponding package, check details
   #
   my $refPacksWithSameName = $$refPackages{$packName};
   my $varPacksWithSameName = $$varPackages{$packName};
   #
   # Match reference packages against variant packages (matched variant packages are marked MATCHED)
   #
   for my $refCompoKey (keys %$refPacksWithSameName) {
      if (exists $$varPacksWithSameName{$refCompoKey}) {
         # perfect match
         my $varPackDetails = $$varPacksWithSameName{$refCompoKey};
         $$varPackDetails{MATCHED} = 1
      }
      else {
         # imperfect match; register difference
         my $refPackDetails = $$refPacksWithSameName{$refCompoKey};
         findVariantCorrespondingToReference($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disappearedPackageList);
      }
   }
   #
   # Collect still unmatched variant packages
   #
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      my $matched        = $$varPackDetails{MATCHED};
      if (!defined($matched) || !$matched) {
         my $details = { NAME        => $packName,
                         VAR_VENDOR  => $$varPackDetails{VENDOR} ,
                         VAR_VERSION => $$varPackDetails{VERSION},
                         VAR_RELEASE => $$varPackDetails{RELEASE}, };
         if (!$drgarch) {
            $$details{VAR_ARCH} = $$varPackDetails{ARCH}
         }
         push(@$appearedPackageList,$details)
      }
   }
}

for my $packName (sort keys %$varPackages) {
   #
   # If there is no corresponding package (with the same name) in the reference, register an appearing package
   # 
   if (!exists $$refPackages{$packName}) {
      $$appearedPackageNames{$packName} = 1
   }
}

# ----
# Prettyprint out
# ----

# determine max length of the package name first

my $maxPackName = 0;

{ 
   for my $str (keys %$disappearedPackageNames , keys %$appearedPackageNames) { 
      my $len = length($str); 
      if ($len > $maxPackName) { $maxPackName = $len }
   }
   for my $packDetails (@$changedPackageList, @$disappearedPackageList, @$appearedPackageList) {
      my $len = length("$$packDetails{NAME}");
      if ($len > $maxPackName) { $maxPackName = $len }
   }
}

# printout appeared/disappeared packages (name only)
   
{
   my $format = "%-${maxPackName}s : %s\n";
   for my $str (sort keys %$disappearedPackageNames) { 
      print sprintf($format,$str,"Missing in the variant");
   }
   for my $str (sort keys %$appearedPackageNames) { 
      print sprintf($format,$str,"Newly added in the variant");
   }
}

# printout changed packages 

{
   my $maxLen = buildMaxLengthHash($changedPackageList);

   my $maxRefVerRel  = $$maxLen{REF_VERSION} + 3 + $$maxLen{REF_RELEASE} + 2;
   my $maxVarVerRel  = $$maxLen{VAR_VERSION} + 3 + $$maxLen{VAR_RELEASE} + 2;
   my $maxRefVendor  = $$maxLen{REF_VENDOR}  + 2; # +2 to accomodate quotes
   my $maxRefArch    = $$maxLen{REF_ARCH}    + 2; # +2 to accomodate quotes

   my $format = "%-${maxPackName}s : Changed: %-${maxRefVerRel}s ---> %-${maxVarVerRel}s    (%-${maxRefVendor}s";
 
   if ($drgarch) { 
      $format .= ")\n";
   }
   else {
      $format .= ", %-${maxRefArch}s)\n";
   }

   for my $packDetails (sort detailHashSort @$changedPackageList) {
      my $packName   = $$packDetails{NAME};        # always exists
      my $refVersion = $$packDetails{REF_VERSION}; # always exists
      my $refRelease = $$packDetails{REF_RELEASE}; # always exists
      my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
      my $varVersion = $$packDetails{VAR_VERSION}; # always exists
      my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
      if ($drgarch) {
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'");
      }
      else {
         my $refArch = $$packDetails{REF_ARCH};
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'","'$refArch'");
      } 
   }
}

# printout packages that appeared/disappeared but for which a package with the same name already existed

{

   my $maxLen = buildMaxLengthHash($appearedPackageList);

   my $maxVersion = $$maxLen{REF_VERSION} > $$maxLen{VAR_VERSION} ? $$maxLen{REF_VERSION} : $$maxLen{VAR_VERSION};
   my $maxRelease = $$maxLen{REF_RELEASE} > $$maxLen{VAR_RELEASE} ? $$maxLen{REF_RELEASE} : $$maxLen{VAR_RELEASE};
   my $maxVerRel  = $maxVersion + 3 + $maxRelease + 2; # +2 to accomodate quotes
   my $maxVendor  = ($$maxLen{REF_VENDOR}  > $$maxLen{VAR_VENDOR}  ? $$maxLen{REF_VENDOR}  : $$maxLen{VAR_VENDOR}) + 2; # +2 to accomodate quotes
   my $maxArch    = ($$maxLen{REF_ARCH}    > $$maxLen{VAR_ARCH}    ? $$maxLen{REF_ARCH}    : $$maxLen{VAR_ARCH})   + 2; # +2 to accomodate quotes

   my $disappearedFormat = "%-${maxPackName}s : %-${maxVerRel}s in reference has no counterpart in variant (%-${maxVendor}s";
   my $appearedFormat    = "%-${maxPackName}s : %-${maxVerRel}s in variant has no counterpart in reference (%-${maxVendor}s";
 
   if ($drgarch) { 
      $disappearedFormat .= ")\n";
      $appearedFormat    .= ")\n";
   }
   else {
      $disappearedFormat .= ", %-${maxArch}s)\n";
      $appearedFormat    .= ", %-${maxArch}s)\n";
   }

   for my $packDetails (sort detailHashSort @$disappearedPackageList) {
      my $packName   = $$packDetails{NAME};        # always exists
      my $refVersion = $$packDetails{REF_VERSION}; # always exists
      my $refRelease = $$packDetails{REF_RELEASE}; # always exists
      my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
      if ($drgarch) {
         print sprintf($disappearedFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'");
      }
      else {
         my $refArch = $$packDetails{REF_ARCH};
         print sprintf($disappearedFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'","'$refArch'");
      }
   }

   for my $packDetails (sort detailHashSort @$appearedPackageList) {
      my $packName   = $$packDetails{NAME};        # always exists
      my $varVersion = $$packDetails{VAR_VERSION}; # always exists
      my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
      my $varVendor  = $$packDetails{VAR_VENDOR};  # always exists
      if ($drgarch) {
         print sprintf($appearedFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'");
      }
      else {
         my $varArch = $$packDetails{VAR_ARCH};
         print sprintf($appearedFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'","'$varArch'");
      }
   }
}

# 
# Print results for a copy-and-paste into the command line of "yum"
#

if ($print && (keys %$appearedPackageNames)) {
   print "Packages to be added to variant:\n";
   print join(" ",sort keys %$appearedPackageNames);
   print "\n"
}









# --------------------------------------------------------------------------------
# Build map of "max string length encountered" for a set of keys
# --------------------------------------------------------------------------------

sub buildMaxLengthHash {
   my($packDetailsList) = @_;
   my $maxLen = {};
   my $keys   = [ 'REF_VENDOR','REF_VERSION','REF_RELEASE','VAR_VERSION','VAR_RELEASE','REF_ARCH', 'VAR_VENDOR', 'VAR_ARCH' ];
   for my $key (@$keys) { 
      $$maxLen{$key} = 0 
   }
   for my $packDetails (@$packDetailsList) {
      for my $key (@$keys) { 
         if (exists $$packDetails{$key}) {            
            my $len = length("$$packDetails{$key}");
            if ($len > $$maxLen{$key}) { $$maxLen{$key} = $len }
         }
      }
   }
   return $maxLen
}

# --------------------------------------------------------------------------------
# Sort two package detail hashes by name
# --------------------------------------------------------------------------------

sub detailHashSort {
   my $name_a = $$a{NAME};
   my $name_b = $$b{NAME};
   return $name_a cmp $name_b
}

# --------------------------------------------------------------------------------
# Inner loop of comparison
# --------------------------------------------------------------------------------

sub findVariantCorrespondingToReference {
   my($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disappearedPackageList) = @_;
   my $found      = 0; 
   my $packName   = $$refPackDetails{NAME};
   my $refVersion = $$refPackDetails{VERSION};
   my $refRelease = $$refPackDetails{RELEASE};
   my $refVendor  = $$refPackDetails{VENDOR};
   my $changeDetails = { NAME        => $packName,
                         REF_VENDOR  => $refVendor,
                         REF_VERSION => $refVersion,
                         REF_RELEASE => $refRelease };
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      die unless ($$varPackDetails{NAME} eq $packName);
      my $varVersion  = $$varPackDetails{VERSION};
      my $varRelease  = $$varPackDetails{RELEASE};
      my $varVendor   = $$varPackDetails{VENDOR};
      # we know the package has the same name but that otherwise doesn't match fully
      # find out what actually matches; we demand that the vendor match
      if ($refVendor eq $varVendor) {
         if ($drgarch) {
            $$changeDetails{VAR_VERSION} = $varVersion;
            $$changeDetails{VAR_RELEASE} = $varRelease;
            push(@$changedPackageList,$changeDetails);
            # Mark that the variant package has been considered so that it can be skipped in the next loop
            $$varPackDetails{MATCHED} = 1;
            $found++
         }
         else {
            my $varArch = $$varPackDetails{ARCH};
            my $refArch = $$refPackDetails{ARCH};
            if ($refArch eq $varArch) {
               $$changeDetails{VAR_VERSION} = $varVersion;
               $$changeDetails{VAR_RELEASE} = $varRelease;
               $$changeDetails{REF_ARCH}    = $refArch;
               push(@$changedPackageList,$changeDetails);
               # Mark that the variant package has been considered so that it can be skipped in the next loop
               $$varPackDetails{MATCHED} = 1;
               $found++
            }
         }
      }
   }
   #
   # If nothing was found at loop's end, register that (happens there is a package with the same name but
   # differing vendors or differing architectures)
   #
   if (!$found) {
      if (!$drgarch) { 
         $$changeDetails{REF_ARCH} = $$refPackDetails{ARCH}
      } 
      push(@$disappearedPackageList,$changeDetails)
   }
}

# --------------------------------------------------------------------------------
# Just read a file
# --------------------------------------------------------------------------------

sub slurpFile {
   my($file,$type) = @_;
   my $res = open(my $rfh,"<",$file);
   if (!$res) {
      print STDERR "Could not open the $type file '$file' for reading: $! -- exiting\n";
      exit 1
   }
   my @lines = <$rfh>;
   close($rfh) or die "Could not close type file '$file': $!\n";
   return \@lines
}

# --------------------------------------------------------------------------------
# Parse bunch of "lines" read from "file" and register package entries in "hash".
#
# Hash key is the name of the package (i.e. the "software name" with no version
# or release string). Several entires with the same package name may exist. Thus:
#
# Hash value is itself a hash for which:
#
#    Hash key is a string composed of the strings for "version,release,vendor,architecture"
#       or "version,release,vendor" if architecture shall be diregarded.
#
#    Hash value is itself a hash which basically repeats the value stringified in the key
#       for easier retrieval:
#
#       Hash key is a composite of NAME, VERSION, RELEASE, VENDOR and possibly ARCH
#       (the "composite key")
#
#       Hash value is simply the value string corresponding to key
#
# --------------------------------------------------------------------------------

sub registerPackages {
   my($hash,$lines,$file,$drgarch) = @_;
   for my $line (@$lines) {
      chomp $line;
      $line =~ s/Â·/ /g; # spaces may have been replaced by dots for better legibility, re-replace
      if ($line =~ /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S.+?)\s*:\s+(\S{9})\s+/) {
         my $name    = $1;
         my $version = $2;
         my $release = $3;
         my $arch    = $4;
         my $vendor  = $5;
         if (! exists $$hash{$name}) {
            $$hash{$name} = {}
         }
         my $subHash  = $$hash{$name};
         my $compoKey = "$version,$release,$vendor";
         if ($drgarch) {
            # disregard architecture; this may overwrite existing hash entry for another architecture
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release ,
                                     VENDOR  => $vendor } 
         }
         else {
            $compoKey = "$compoKey,$arch";
            if (exists $$subHash{$compoKey}) {
               print STDERR "An entry for package '$name' with version '$version', release '$release', architecture '$arch', vendor '$vendor' already exists in file '$file' -- exiting\n";
               exit 2
            }
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release , 
                                     VENDOR  => $vendor ,
                                     ARCH    => $arch }
         }
      }
      else {
         print STDERR "Could not parse line '$line'\n";
      }
   }
}

