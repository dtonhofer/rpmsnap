#!/usr/bin/perl -w

# ================================================================================
# "rpmsnapcmp.pl": Compare two files generated by "rpmsnap.pl" at different points
# in time or on different machines.
#
# Arguments passed: two rpmsnap files, the "reference" and the "variant" (in 
# that order). The variant is compared against the reference and the list of
# differences is output. In case you are looking for a list of missing packages
# to pass to "yum", use the "-p" one-liner.
#
# You can also use the ouput to look for and install missing packages.
# For example, if the run of rpmsnapcmp.pl has yielded output "OUT", you
# could consider installing missing "perl" packages using:
#
# grep "perl" OUT | grep "Missing" | cut --field=1 --delimiter=":" | xargs yum -y install
#
# Maintainer: David Tonhofer <ronerycoder@gluino.name>
# ================================================================================
# Distributed under the MIT License,
# See http://www.opensource.org/licenses/mit-license.php
# 
# Copyright (c) 2011 by M-PLIFY S.A. 
#                       21, rue Glesener
#                       L-1631 Luxembourg
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ================================================================================

use strict;

# ----
# How do we call the files passed to the program?
# The first one given is the "reference".
# The second one given is the "variant" which is compared against the "reference".
# One could also name them "left-hand" and "right-hand", which is clearer for the user.
# ----

# my $refName = "left-hand";
# my $varName = "right-hand";
my $refName = "reference";
my $varName = "variant";

# ----
# Simple argument checking and processing. 
# Use package "Getopt::Long" for anything more complex than this!
# ----

if (@ARGV < 2) {
   print STDERR "You have to give two files:\n";
   print STDERR "  1) The left-hand (the reference) file.\n"; 
   print STDERR "  2) The right-hand (the variant) file.\n";
   print STDERR "The variant is then compared against the reference.\n";
   print STDERR "Additional options:\n";
   print STDERR "  -r : reverse reference and variant files; allows you to easily switch files around\n";
   print STDERR "  -p : list packages missing in variant in one-liner; for further processing via yum\n";
   print STDERR "  -a : disregard 'architecture' value when comparing; may give better matches\n";
   exit 1
}

my $ix      = 0;
my $reverse = 0;
my $print   = 0;
my $drgarch = 0;
my $referenceFile;
my $variantFile;

while (defined $ARGV[$ix]) {
   if ($ARGV[$ix] eq '-r') { 
      $reverse = 1
   }
   elsif ($ARGV[$ix] eq '-p') { 
      $print = 1
   }
   elsif ($ARGV[$ix] eq '-a') { 
      $drgarch = 1
   }
   elsif (!($ARGV[$ix] =~ /^-/)) {
      if (!$referenceFile) {
         $referenceFile = $ARGV[$ix]
      }
      elsif (!$variantFile) {
         $variantFile = $ARGV[$ix]
      }
      else {
         die "Unexpected filename $ARGV[$ix]\n";
      }
   }
   else {
      die "Unusable argument $ARGV[$ix]\n"
   }
   $ix++
}

if (!$variantFile) {
   print STDERR "The $varName file was not given -- exiting\n";
   exit 1
}

if (!$referenceFile) {
   print STDERR "The $refName file was not given -- exiting\n";
   exit 1
}

if ($reverse) {
   ($variantFile,$referenceFile) = ($referenceFile,$variantFile)
}

# ----
# Check that files exist, then read them into (references to) array of lines
# ----

if (! -f $variantFile) {
   print STDERR "The $varName file '$variantFile' does not exist -- exiting\n";
   exit 1
}

if (! -f $referenceFile) {
   print STDERR "The $refName file '$referenceFile' does not exist -- exiting\n";
   exit 1
}

my $variantLines   = slurpFile($variantFile,$varName);
my $referenceLines = slurpFile($referenceFile,$refName);

# ----
# Interpret the lines just read, filling hashes mapping "package names" to "package descriptors"
# ----

my $varPackages = {};
my $refPackages = {};

registerPackages($varPackages,$variantLines,$variantFile,$drgarch);
registerPackages($refPackages,$referenceLines,$referenceFile,$drgarch);

# ----
# Compare contents of $varPackages and $refPackages
# ----

my $disPackageNames    = {} ; # packages that *disappeared* when going from "ref" to "var"; map package name to "1"
my $appPackageNames    = {} ; # packages that *appeared* when going from "ref" to "var"; map package name to "1"
my $changedPackageList = [] ; # accumulate detail hashes of changed packages
my $disPackageList     = [] ; # accumulate detail hashes of reference packages not matching
my $appPackageList     = [] ; # accumulate detail hashes of variant packages not matching

for my $packName (sort keys %$refPackages) {
   #
   # If there is no corresponding package (with the same name) in the variant, register a missing package
   # 
   if (!exists $$varPackages{$packName}) {
      $$disPackageNames{$packName} = 1;
      next
   }
   #
   # Otherwise if there is at least one corresponding package, check details
   #
   my $refPacksWithSameName = $$refPackages{$packName};
   my $varPacksWithSameName = $$varPackages{$packName};
   #
   # Match reference packages against variant packages (matched variant packages are marked MATCHED)
   #
   for my $refCompoKey (keys %$refPacksWithSameName) {
      if (exists $$varPacksWithSameName{$refCompoKey}) {
         # perfect match
         my $varPackDetails = $$varPacksWithSameName{$refCompoKey};
         $$varPackDetails{MATCHED} = 1
      }
      else {
         # imperfect match; register difference
         my $refPackDetails = $$refPacksWithSameName{$refCompoKey};
         findVariantCorrespondingToReference($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disPackageList);
      }
   }
   #
   # Collect still unmatched variant packages
   #
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      my $matched        = $$varPackDetails{MATCHED};
      if (!defined($matched) || !$matched) {
         my $details = { NAME        => $packName,
                         VAR_VENDOR  => $$varPackDetails{VENDOR} ,
                         VAR_VERSION => $$varPackDetails{VERSION},
                         VAR_RELEASE => $$varPackDetails{RELEASE}, };
         if (!$drgarch) {
            $$details{VAR_ARCH} = $$varPackDetails{ARCH}
         }
         push(@$appPackageList,$details)
      }
   }
}

for my $packName (sort keys %$varPackages) {
   #
   # If there is no corresponding package (with the same name) in the reference, register an appearing package
   # 
   if (!exists $$refPackages{$packName}) {
      $$appPackageNames{$packName} = 1
   }
}

# ----
# Prettyprint out
# ----

# determine max length of the package name first

my $maxPackName = 0;

{ 
   for my $str (keys %$disPackageNames , keys %$appPackageNames) { 
      my $len = length($str); 
      if ($len > $maxPackName) { $maxPackName = $len }
   }
   for my $packDetails (@$changedPackageList, @$disPackageList, @$appPackageList) {
      my $len = length("$$packDetails{NAME}");
      if ($len > $maxPackName) { $maxPackName = $len }
   }
}

# printout appeared/disappeared packages (names only; one could consider also adding package information)
   
{
   my $format = "%-${maxPackName}s : %s\n";
   for my $str (sort keys %$disPackageNames) { 
      print sprintf($format,$str,"Missing in the $varName, but found in the $refName");
   }
   for my $str (sort keys %$appPackageNames) { 
      print sprintf($format,$str,"Found in the $varName, but missing in the $refName");
   }
}

# printout packages that changed

{
   my $maxLenHash = buildMaxLengthHash($changedPackageList);

   my $maxRefVerRel  = $$maxLenHash{REF_VERSION} + 3 + $$maxLenHash{REF_RELEASE} + 2;
   my $maxVarVerRel  = $$maxLenHash{VAR_VERSION} + 3 + $$maxLenHash{VAR_RELEASE} + 2;
   my $maxRefVendor  = $$maxLenHash{REF_VENDOR}  + 2; # +2 to accomodate quotes
   my $maxRefArch    = $$maxLenHash{REF_ARCH}    + 2; # +2 to accomodate quotes

   my $format = "%-${maxPackName}s : Changed: %-${maxRefVerRel}s ---> %-${maxVarVerRel}s    (%-${maxRefVendor}s";
 
   if ($drgarch) { 
      $format .= ")\n";
   }
   else {
      $format .= ", %-${maxRefArch}s)\n";
   }

   for my $packDetails (sort detailHashSort @$changedPackageList) {
      my $packName   = $$packDetails{NAME};        # always exists
      my $refVersion = $$packDetails{REF_VERSION}; # always exists
      my $refRelease = $$packDetails{REF_RELEASE}; # always exists
      my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
      my $varVersion = $$packDetails{VAR_VERSION}; # always exists
      my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
      if ($drgarch) {
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'");
      }
      else {
         my $refArch = $$packDetails{REF_ARCH};
         print sprintf($format,"$packName","'$refVersion / $refRelease'","'$varVersion / $varRelease'","'$refVendor'","'$refArch'");
      } 
   }
}

# printout packages that appeared/disappeared but for which a package with the same name (but another architecture etc) already existed

{

   my @ovrPackageList = ( @$appPackageList, @$disPackageList ); # merge lists
   
   my $maxLenHash = buildMaxLengthHash( \@ovrPackageList );

   my $maxVersion = max($$maxLenHash{REF_VERSION} , $$maxLenHash{VAR_VERSION});
   my $maxRelease = max($$maxLenHash{REF_RELEASE} , $$maxLenHash{VAR_RELEASE});

   my $maxVerRel  = $maxVersion + 3 + $maxRelease                                + 2; # +2 to accommodate quotes
   my $maxVendor  = max($$maxLenHash{REF_VENDOR}  , $$maxLenHash{VAR_VENDOR})    + 2; # +2 to accommodate quotes
   my $maxArch    = max($$maxLenHash{REF_ARCH}    , $$maxLenHash{VAR_ARCH})      + 2; # +2 to accommodate quotes

   my $disFormat = "%-${maxPackName}s : %-${maxVerRel}s in $refName has no counterpart in $varName (%-${maxVendor}s";
   my $appFormat = "%-${maxPackName}s : %-${maxVerRel}s in $varName has no counterpart in $refName (%-${maxVendor}s";
 
   if ($drgarch) { 
      $disFormat .= ")\n";
      $appFormat    .= ")\n";
   }
   else {
      $disFormat .= ", %-${maxArch}s)\n";
      $appFormat    .= ", %-${maxArch}s)\n";
   }

   # Sort the "appeared" and "disappered" list, then interleave the lines when printing.
   # This makes for a better-to-read printout than just printing all the "appeared" then
   # all the "disappeared" packages in separate loops.
   
   my @disSortedL = (sort detailHashSort @$disPackageList);
   my @appSortedL = (sort detailHashSort @$appPackageList);

   my $disSorted = \@disSortedL;
   my $appSorted = \@appSortedL;

   my $disIndex    = 0;
   my $disIndexMax = @$disSorted * 1;
   my $appIndex    = 0;
   my $appIndexMax = @$appSorted * 1;
   
   while ($disIndex < $disIndexMax || $appIndex < $appIndexMax) {
      my $disPackDetails; 
      my $appPackDetails;
      #
      # Obtain package details if there are any in the repective list
      #  
      if ($disIndex < $disIndexMax) { $disPackDetails = $$disSorted[$disIndex] }
      if ($appIndex < $appIndexMax) { $appPackDetails = $$appSorted[$appIndex] }
      #
      # Find out which one to write out depending on what exists
      #   
      if (!$disPackDetails) {
         printAppearedPackage($appPackDetails,$drgarch,$appFormat);
         $appIndex++
      }
      elsif (!$appPackDetails) {
         printDisappearedPackage($disPackDetails,$drgarch,$disFormat);
         $disIndex++
      }
      else {
         die unless $disPackDetails && $appPackDetails;
         my $cmp = ($$disPackDetails{NAME} cmp $$appPackDetails{NAME}); # corresponds to "detailHashSort" used above
         if ($cmp <= 0) {
            printDisappearedPackage($disPackDetails,$drgarch,$disFormat);
            $disIndex++         
         }
         else {
            printAppearedPackage($appPackDetails,$drgarch,$appFormat);
            $appIndex++
         }
      }
   }
}

# 
# Additionally print results for a copy-and-paste into the command line of "yum"
# if so asked via "print" flag: the packages that disappeared in the variant, and
# thus may have to be added.
#

if ($print && (keys %$disPackageNames)) {
   print "Packages to be added to $varName:\n";
   print join(" ",sort keys %$disPackageNames);
   print "\n"
}

# --------------------------------------------------------------------------------
# Print the "disappeared" package, i.e. the reference part of "packDetails"
# --------------------------------------------------------------------------------

sub printDisappearedPackage {
   my($packDetails,$drgarch,$disFormat) = @_;
   my $packName   = $$packDetails{NAME};        # always exists
   my $refVersion = $$packDetails{REF_VERSION}; # always exists
   my $refRelease = $$packDetails{REF_RELEASE}; # always exists
   my $refVendor  = $$packDetails{REF_VENDOR};  # always exists
   if ($drgarch) {
      print sprintf($disFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'");
   }
   else {
      my $refArch = $$packDetails{REF_ARCH};
      print sprintf($disFormat,"$packName","'$refVersion / $refRelease'","'$refVendor'","'$refArch'");
   }
}

# --------------------------------------------------------------------------------
# Print the "appeared" package, i.e. the variant part of "packDetails"
# --------------------------------------------------------------------------------

sub printAppearedPackage {
   my($packDetails,$drgarch,$appFormat) = @_;
   my $packName   = $$packDetails{NAME};        # always exists
   my $varVersion = $$packDetails{VAR_VERSION}; # always exists
   my $varRelease = $$packDetails{VAR_RELEASE}; # always exists
   my $varVendor  = $$packDetails{VAR_VENDOR};  # always exists
   if ($drgarch) {
      print sprintf($appFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'");
   }
   else {
      my $varArch = $$packDetails{VAR_ARCH};
      print sprintf($appFormat,"$packName","'$varVersion / $varRelease'","'$varVendor'","'$varArch'");
   }
}


# --------------------------------------------------------------------------------
# Build map of "max string length encountered" for a set of keys
# Each of the "keys" given below will have a value; if the key is not encountered
# in the passed hash, it will be 0.
# --------------------------------------------------------------------------------

sub buildMaxLengthHash {
   my($packDetailsList) = @_;
   my $maxLenHash = {};
   my $keys   = [ 'REF_VENDOR','REF_VERSION','REF_RELEASE','VAR_VERSION','VAR_RELEASE','REF_ARCH', 'VAR_VENDOR', 'VAR_ARCH' ];
   for my $key (@$keys) { 
      $$maxLenHash{$key} = 0 
   }
   for my $packDetails (@$packDetailsList) {
      for my $key (@$keys) { 
         if (exists $$packDetails{$key}) {            
            my $len = length("$$packDetails{$key}");
            if ($len > $$maxLenHash{$key}) { $$maxLenHash{$key} = $len }
         }
      }
   }
   return $maxLenHash
}

# --------------------------------------------------------------------------------
# Sort two package detail hashes by name
# --------------------------------------------------------------------------------

sub detailHashSort {
   my $name_a = $$a{NAME};
   my $name_b = $$b{NAME};
   return $name_a cmp $name_b
}

# --------------------------------------------------------------------------------
# Inner loop of comparison
# --------------------------------------------------------------------------------

sub findVariantCorrespondingToReference {
   my($varPacksWithSameName,$refPackDetails,$drgarch,$changedPackageList,$disappearedPackageList) = @_;
   my $found      = 0; 
   my $packName   = $$refPackDetails{NAME};
   my $refVersion = $$refPackDetails{VERSION};
   my $refRelease = $$refPackDetails{RELEASE};
   my $refVendor  = $$refPackDetails{VENDOR};
   my $changeDetails = { NAME        => $packName,
                         REF_VENDOR  => $refVendor,
                         REF_VERSION => $refVersion,
                         REF_RELEASE => $refRelease };
   for my $varCompoKey (keys %$varPacksWithSameName) {
      my $varPackDetails = $$varPacksWithSameName{$varCompoKey};
      die unless ($$varPackDetails{NAME} eq $packName);
      my $varVersion  = $$varPackDetails{VERSION};
      my $varRelease  = $$varPackDetails{RELEASE};
      my $varVendor   = $$varPackDetails{VENDOR};
      # we know the package has the same name but that otherwise doesn't match fully
      # find out what actually matches; we demand that the vendor match
      if ($refVendor eq $varVendor) {
         if ($drgarch) {
            $$changeDetails{VAR_VERSION} = $varVersion;
            $$changeDetails{VAR_RELEASE} = $varRelease;
            push(@$changedPackageList,$changeDetails);
            # Mark that the variant package has been considered so that it can be skipped in the next loop
            $$varPackDetails{MATCHED} = 1;
            $found++
         }
         else {
            my $varArch = $$varPackDetails{ARCH};
            my $refArch = $$refPackDetails{ARCH};
            if ($refArch eq $varArch) {
               $$changeDetails{VAR_VERSION} = $varVersion;
               $$changeDetails{VAR_RELEASE} = $varRelease;
               $$changeDetails{REF_ARCH}    = $refArch;
               push(@$changedPackageList,$changeDetails);
               # Mark that the variant package has been considered so that it can be skipped in the next loop
               $$varPackDetails{MATCHED} = 1;
               $found++
            }
         }
      }
   }
   #
   # If nothing was found at loop's end, register that (happens there is a package with the same name but
   # differing vendors or differing architectures)
   #
   if (!$found) {
      if (!$drgarch) { 
         $$changeDetails{REF_ARCH} = $$refPackDetails{ARCH}
      } 
      push(@$disappearedPackageList,$changeDetails)
   }
}

# --------------------------------------------------------------------------------
# Just read a file
# --------------------------------------------------------------------------------

sub slurpFile {
   my($file,$type) = @_;
   my $res = open(my $rfh,"<",$file);
   if (!$res) {
      print STDERR "Could not open the $type file '$file' for reading: $! -- exiting\n";
      exit 1
   }
   my @lines = <$rfh>;
   close($rfh) or die "Could not close type file '$file': $!\n";
   return \@lines
}

# --------------------------------------------------------------------------------
# Parse bunch of "lines" read from "file" and register package entries in "hash".
#
# Hash key is the name of the package (i.e. the "software name" with no version
# or release string). Several entires with the same package name may exist. Thus:
#
# Hash value is itself a hash for which:
#
#    Hash key is a string composed of the strings for "version,release,vendor,architecture"
#       or "version,release,vendor" if architecture shall be diregarded.
#
#    Hash value is itself a hash which basically repeats the value stringified in the key
#       for easier retrieval:
#
#       Hash key is a composite of NAME, VERSION, RELEASE, VENDOR and possibly ARCH
#       (the "composite key")
#
#       Hash value is simply the value string corresponding to key
# --------------------------------------------------------------------------------

sub registerPackages {
   my($hash,$lines,$file,$drgarch) = @_;
   for my $line (@$lines) {
      chomp $line;
      $line =~ s/Â·/ /g; # spaces may have been replaced by dots for better legibility, re-replace
      if ($line =~ /^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S.+?)\s*:\s+(\S{9})\s+/) {
         my $name    = $1;
         my $version = $2;
         my $release = $3;
         my $arch    = $4;
         my $vendor  = $5;
         if (! exists $$hash{$name}) {
            $$hash{$name} = {}
         }
         my $subHash  = $$hash{$name};
         my $compoKey = "$version,$release,$vendor";
         if ($drgarch) {
            # disregard architecture; this may overwrite existing hash entry for another architecture
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release ,
                                     VENDOR  => $vendor } 
         }
         else {
            $compoKey = "$compoKey,$arch";
            if (exists $$subHash{$compoKey}) {
               print STDERR "An entry for package '$name' with version '$version', release '$release', architecture '$arch', vendor '$vendor' already exists in file '$file' -- exiting\n";
               exit 2
            }
            $$subHash{$compoKey} = { NAME    => $name ,
                                     VERSION => $version , 
                                     RELEASE => $release , 
                                     VENDOR  => $vendor ,
                                     ARCH    => $arch }
         }
      }
      else {
         print STDERR "Could not parse line '$line'\n"
      }
   }
}

# --------------------------------------------------------------------------------
# Numerical max
# --------------------------------------------------------------------------------

sub max {
   my($a,$b) = @_;
   if ($a > $b) {
      return $a
   }
   else {
      return $b
   }
}

